// Code generated by parsley for scanning JSON strings. DO NOT EDIT.
package resource

import (
	parse "github.com/Soreing/parsley"
	reader "github.com/Soreing/parsley/reader"
)

var _ *reader.Reader

func (o *AppHostedMediaConfig) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [2]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "blob" {
				c[1] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "blob" && c[1] {
						o.Blob, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *AppHostedMediaConfig) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []AppHostedMediaConfig, err error) {
	var e AppHostedMediaConfig
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]AppHostedMediaConfig, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *AppHostedMediaConfig) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []AppHostedMediaConfig, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []AppHostedMediaConfig{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *Call) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [21]bool{}
	f := [21][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "callbackUri" {
				c[1] = true
			} else if k == "callChainId" {
				c[2] = true
			} else if k == "callOptions" {
				c[3], f[3] = true, filter[i].Filter
			} else if k == "callRoutes" {
				c[4], f[4] = true, filter[i].Filter
			} else if k == "chatInfo" {
				c[5], f[5] = true, filter[i].Filter
			} else if k == "direction" {
				c[6] = true
			} else if k == "id" {
				c[7] = true
			} else if k == "incomingContext" {
				c[8], f[8] = true, filter[i].Filter
			} else if k == "mediaConfig" {
				c[9], f[9] = true, filter[i].Filter
			} else if k == "mediaState" {
				c[10] = true
			} else if k == "meetingInfo" {
				c[11], f[11] = true, filter[i].Filter
			} else if k == "myParticipantId" {
				c[12] = true
			} else if k == "requestedModalities" {
				c[13] = true
			} else if k == "resultInfo" {
				c[14], f[14] = true, filter[i].Filter
			} else if k == "source" {
				c[15], f[15] = true, filter[i].Filter
			} else if k == "state" {
				c[16] = true
			} else if k == "subject" {
				c[17] = true
			} else if k == "targets" {
				c[18], f[18] = true, filter[i].Filter
			} else if k == "toneInfo" {
				c[19], f[19] = true, filter[i].Filter
			} else if k == "transcription" {
				c[20], f[20] = true, filter[i].Filter
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "callbackUri" && c[1] {
						o.CallbackUri, err = r.String()
					} else if string(key) == "callChainId" && c[2] {
						o.CallChainId, err = r.String()
					} else if string(key) == "callOptions" && c[3] {
						o.CallOptions = &OutgoingCallOptions{}
						err = o.CallOptions.DecodeObjectPJSON(r, f[3])
					} else if string(key) == "callRoutes" && c[4] {
						o.CallRoutes, err = (*CallRoute)(nil).DecodeSlicePJSON(r, f[4])
					} else if string(key) == "chatInfo" && c[5] {
						o.ChatInfo = &ChatInfo{}
						err = o.ChatInfo.DecodeObjectPJSON(r, f[5])
					} else if string(key) == "direction" && c[6] {
						o.Direction, err = r.String()
					} else if string(key) == "id" && c[7] {
						o.Id, err = r.String()
					} else if string(key) == "incomingContext" && c[8] {
						o.IncomingContext = &IncomingContext{}
						err = o.IncomingContext.DecodeObjectPJSON(r, f[8])
					} else if string(key) == "mediaConfig" && c[9] {
						o.MediaConfig = &AnyResource{}
						err = o.MediaConfig.DecodeObjectPJSON(r, f[9])
					} else if string(key) == "mediaState" && c[10] {
						o.MediaState, err = r.String()
					} else if string(key) == "meetingInfo" && c[11] {
						o.MeetingInfo = &AnyResource{}
						err = o.MeetingInfo.DecodeObjectPJSON(r, f[11])
					} else if string(key) == "myParticipantId" && c[12] {
						o.MyParticipantId, err = r.String()
					} else if string(key) == "requestedModalities" && c[13] {
						o.RequestedModalities, err = r.Strings()
					} else if string(key) == "resultInfo" && c[14] {
						o.ResultInfo = &ResultInfo{}
						err = o.ResultInfo.DecodeObjectPJSON(r, f[14])
					} else if string(key) == "source" && c[15] {
						o.Source = &ParticipantInfo{}
						err = o.Source.DecodeObjectPJSON(r, f[15])
					} else if string(key) == "state" && c[16] {
						o.State, err = r.String()
					} else if string(key) == "subject" && c[17] {
						o.Subject, err = r.String()
					} else if string(key) == "targets" && c[18] {
						o.Targets, err = (*InvitationParticipantInfo)(nil).DecodeSlicePJSON(r, f[18])
					} else if string(key) == "toneInfo" && c[19] {
						o.ToneInfo = &ToneInfo{}
						err = o.ToneInfo.DecodeObjectPJSON(r, f[19])
					} else if string(key) == "transcription" && c[20] {
						o.Transcription = &CallTranscriptionInfo{}
						err = o.Transcription.DecodeObjectPJSON(r, f[20])
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *Call) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []Call, err error) {
	var e Call
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]Call, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *Call) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []Call, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []Call{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *CallRoute) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [4]bool{}
	f := [4][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "final" {
				c[1], f[1] = true, filter[i].Filter
			} else if k == "original" {
				c[2], f[2] = true, filter[i].Filter
			} else if k == "routingType" {
				c[3] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "final" && c[1] {
						o.Final = &IdentitySet{}
						err = o.Final.DecodeObjectPJSON(r, f[1])
					} else if string(key) == "original" && c[2] {
						o.Original = &IdentitySet{}
						err = o.Original.DecodeObjectPJSON(r, f[2])
					} else if string(key) == "routingType" && c[3] {
						o.RoutingType, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *CallRoute) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []CallRoute, err error) {
	var e CallRoute
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]CallRoute, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *CallRoute) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []CallRoute, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []CallRoute{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *CallTranscriptionInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [3]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "lastModifiedDateTime" {
				c[1] = true
			} else if k == "state" {
				c[2] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "lastModifiedDateTime" && c[1] {
						o.LastModifiedDateTime, err = r.Time()
					} else if string(key) == "state" && c[2] {
						o.State, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *CallTranscriptionInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []CallTranscriptionInfo, err error) {
	var e CallTranscriptionInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]CallTranscriptionInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *CallTranscriptionInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []CallTranscriptionInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []CallTranscriptionInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *ChatInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [4]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "messageId" {
				c[1] = true
			} else if k == "replyChainMessageId" {
				c[2] = true
			} else if k == "threadId" {
				c[3] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "messageId" && c[1] {
						o.MessageId, err = r.String()
					} else if string(key) == "replyChainMessageId" && c[2] {
						o.ReplyChainMessageId, err = r.String()
					} else if string(key) == "threadId" && c[3] {
						o.ThreadId, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *ChatInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []ChatInfo, err error) {
	var e ChatInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]ChatInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *ChatInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []ChatInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []ChatInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *CommsNotification) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [4]bool{}
	f := [4][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "changeType" {
				c[1] = true
			} else if k == "resourceUrl" {
				c[2] = true
			} else if k == "resourceData" {
				c[3], f[3] = true, filter[i].Filter
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "changeType" && c[1] {
						o.ChangeType, err = r.String()
					} else if string(key) == "resourceUrl" && c[2] {
						o.ResourceUrl, err = r.String()
					} else if string(key) == "resourceData" && c[3] {
						o.ResourceData = &AnyResource{}
						err = o.ResourceData.DecodeObjectPJSON(r, f[3])
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *CommsNotification) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []CommsNotification, err error) {
	var e CommsNotification
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]CommsNotification, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *CommsNotification) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []CommsNotification, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []CommsNotification{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *CommsNotifications) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [2]bool{}
	f := [2][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "value" {
				c[1], f[1] = true, filter[i].Filter
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "value" && c[1] {
						o.Value, err = (*CommsNotification)(nil).DecodeSlicePJSON(r, f[1])
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *CommsNotifications) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []CommsNotifications, err error) {
	var e CommsNotifications
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]CommsNotifications, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *CommsNotifications) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []CommsNotifications, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []CommsNotifications{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *Identity) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [6]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "acsResourceId" {
				c[1] = true
			} else if k == "displayName" {
				c[2] = true
			} else if k == "id" {
				c[3] = true
			} else if k == "identityProvider" {
				c[4] = true
			} else if k == "tenantId" {
				c[5] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "acsResourceId" && c[1] {
						o.AcsResourceId, err = r.String()
					} else if string(key) == "displayName" && c[2] {
						o.DisplayName, err = r.String()
					} else if string(key) == "id" && c[3] {
						o.Id, err = r.String()
					} else if string(key) == "identityProvider" && c[4] {
						o.IdentityProvider, err = r.String()
					} else if string(key) == "tenantId" && c[5] {
						o.TenantId, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *Identity) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []Identity, err error) {
	var e Identity
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]Identity, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *Identity) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []Identity, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []Identity{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *IdentitySet) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [5]bool{}
	f := [5][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "acsUser" {
				c[1], f[1] = true, filter[i].Filter
			} else if k == "application" {
				c[2], f[2] = true, filter[i].Filter
			} else if k == "phone" {
				c[3], f[3] = true, filter[i].Filter
			} else if k == "user" {
				c[4], f[4] = true, filter[i].Filter
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "acsUser" && c[1] {
						o.AcsUser = &Identity{}
						err = o.AcsUser.DecodeObjectPJSON(r, f[1])
					} else if string(key) == "application" && c[2] {
						o.Application = &Identity{}
						err = o.Application.DecodeObjectPJSON(r, f[2])
					} else if string(key) == "phone" && c[3] {
						o.Phone = &Identity{}
						err = o.Phone.DecodeObjectPJSON(r, f[3])
					} else if string(key) == "user" && c[4] {
						o.User = &Identity{}
						err = o.User.DecodeObjectPJSON(r, f[4])
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *IdentitySet) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []IdentitySet, err error) {
	var e IdentitySet
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]IdentitySet, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *IdentitySet) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []IdentitySet, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []IdentitySet{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *IncomingContext) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [5]bool{}
	f := [5][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "sourceParticipantId" {
				c[1] = true
			} else if k == "observedParticipantId" {
				c[2] = true
			} else if k == "onBehalfOf" {
				c[3], f[3] = true, filter[i].Filter
			} else if k == "transferor" {
				c[4], f[4] = true, filter[i].Filter
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "sourceParticipantId" && c[1] {
						o.SourceParticipantId, err = r.String()
					} else if string(key) == "observedParticipantId" && c[2] {
						o.ObservedParticipantId, err = r.String()
					} else if string(key) == "onBehalfOf" && c[3] {
						o.OnBehalfOf = &IdentitySet{}
						err = o.OnBehalfOf.DecodeObjectPJSON(r, f[3])
					} else if string(key) == "transferor" && c[4] {
						o.Transferor = &IdentitySet{}
						err = o.Transferor.DecodeObjectPJSON(r, f[4])
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *IncomingContext) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []IncomingContext, err error) {
	var e IncomingContext
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]IncomingContext, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *IncomingContext) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []IncomingContext, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []IncomingContext{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *InvitationParticipantInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [10]bool{}
	f := [10][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "clientVersion" {
				c[1] = true
			} else if k == "countryCode" {
				c[2] = true
			} else if k == "endpointId" {
				c[3] = true
			} else if k == "endpointType" {
				c[4] = true
			} else if k == "identity" {
				c[5], f[5] = true, filter[i].Filter
			} else if k == "languageId" {
				c[6] = true
			} else if k == "participantId" {
				c[7] = true
			} else if k == "region" {
				c[8] = true
			} else if k == "replacementLink" {
				c[9] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "clientVersion" && c[1] {
						o.ClientVersion, err = r.String()
					} else if string(key) == "countryCode" && c[2] {
						o.CountryCode, err = r.String()
					} else if string(key) == "endpointId" && c[3] {
						o.EndpointId, err = r.String()
					} else if string(key) == "endpointType" && c[4] {
						o.EndpointType, err = r.String()
					} else if string(key) == "identity" && c[5] {
						o.Identity = &IdentitySet{}
						err = o.Identity.DecodeObjectPJSON(r, f[5])
					} else if string(key) == "languageId" && c[6] {
						o.LanguageId, err = r.String()
					} else if string(key) == "participantId" && c[7] {
						o.ParticipantId, err = r.String()
					} else if string(key) == "region" && c[8] {
						o.Region, err = r.String()
					} else if string(key) == "replacementLink" && c[9] {
						o.ReplacementLink, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *InvitationParticipantInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []InvitationParticipantInfo, err error) {
	var e InvitationParticipantInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]InvitationParticipantInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *InvitationParticipantInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []InvitationParticipantInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []InvitationParticipantInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *JoinMeetingIdMeetingInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [3]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "joinMeetingId" {
				c[1] = true
			} else if k == "passcode" {
				c[2] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "joinMeetingId" && c[1] {
						o.JoinMeetingId, err = r.String()
					} else if string(key) == "passcode" && c[2] {
						o.Passcode, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *JoinMeetingIdMeetingInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []JoinMeetingIdMeetingInfo, err error) {
	var e JoinMeetingIdMeetingInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]JoinMeetingIdMeetingInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *JoinMeetingIdMeetingInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []JoinMeetingIdMeetingInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []JoinMeetingIdMeetingInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *MediaInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [3]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "resourceId" {
				c[1] = true
			} else if k == "uri" {
				c[2] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "resourceId" && c[1] {
						o.ResourceId, err = r.String()
					} else if string(key) == "uri" && c[2] {
						o.Uri, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *MediaInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []MediaInfo, err error) {
	var e MediaInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]MediaInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *MediaInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []MediaInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []MediaInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *MediaStream) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [6]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "direction" {
				c[1] = true
			} else if k == "label" {
				c[2] = true
			} else if k == "mediaType" {
				c[3] = true
			} else if k == "serverMuted" {
				c[4] = true
			} else if k == "sourceId" {
				c[5] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "direction" && c[1] {
						o.Direction, err = r.String()
					} else if string(key) == "label" && c[2] {
						o.Label, err = r.String()
					} else if string(key) == "mediaType" && c[3] {
						o.MediaType, err = r.String()
					} else if string(key) == "serverMuted" && c[4] {
						o.ServerMuted, err = r.Boolp()
					} else if string(key) == "sourceId" && c[5] {
						o.SourceId, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *MediaStream) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []MediaStream, err error) {
	var e MediaStream
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]MediaStream, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *MediaStream) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []MediaStream, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []MediaStream{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *OrganizerMeetingInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [2]bool{}
	f := [2][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "organizer" {
				c[1], f[1] = true, filter[i].Filter
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "organizer" && c[1] {
						o.Organizer = &IdentitySet{}
						err = o.Organizer.DecodeObjectPJSON(r, f[1])
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *OrganizerMeetingInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []OrganizerMeetingInfo, err error) {
	var e OrganizerMeetingInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]OrganizerMeetingInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *OrganizerMeetingInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []OrganizerMeetingInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []OrganizerMeetingInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *OutgoingCallOptions) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [3]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "hideBotAfterEscalation" {
				c[1] = true
			} else if k == "isContentSharingNotificationEnabled" {
				c[2] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "hideBotAfterEscalation" && c[1] {
						o.HideBotAfterEscalation, err = r.Boolp()
					} else if string(key) == "isContentSharingNotificationEnabled" && c[2] {
						o.IsContentSharingNotificationEnabled, err = r.Boolp()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *OutgoingCallOptions) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []OutgoingCallOptions, err error) {
	var e OutgoingCallOptions
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]OutgoingCallOptions, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *OutgoingCallOptions) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []OutgoingCallOptions, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []OutgoingCallOptions{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *Participant) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [12]bool{}
	f := [12][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "id" {
				c[1] = true
			} else if k == "info" {
				c[2], f[2] = true, filter[i].Filter
			} else if k == "isIdentityAnonymized" {
				c[3] = true
			} else if k == "isInLobby" {
				c[4] = true
			} else if k == "isMuted" {
				c[5] = true
			} else if k == "mediaStreams" {
				c[6], f[6] = true, filter[i].Filter
			} else if k == "meetingRole" {
				c[7] = true
			} else if k == "metadata" {
				c[8] = true
			} else if k == "publishedStates" {
				c[9], f[9] = true, filter[i].Filter
			} else if k == "recordingInfo" {
				c[10], f[10] = true, filter[i].Filter
			} else if k == "replacementLink" {
				c[11] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "id" && c[1] {
						o.Id, err = r.String()
					} else if string(key) == "info" && c[2] {
						o.Info = &ParticipantInfo{}
						err = o.Info.DecodeObjectPJSON(r, f[2])
					} else if string(key) == "isIdentityAnonymized" && c[3] {
						o.IsIdentityAnonymized, err = r.Bool()
					} else if string(key) == "isInLobby" && c[4] {
						o.IsInLobby, err = r.Bool()
					} else if string(key) == "isMuted" && c[5] {
						o.IsMuted, err = r.Bool()
					} else if string(key) == "mediaStreams" && c[6] {
						o.MediaStreams, err = (*MediaStream)(nil).DecodeSlicePJSON(r, f[6])
					} else if string(key) == "meetingRole" && c[7] {
						o.MeetingRole, err = r.String()
					} else if string(key) == "metadata" && c[8] {
						o.Metadata, err = r.String()
					} else if string(key) == "publishedStates" && c[9] {
						o.PublishedStates, err = (*PublishedState)(nil).DecodeSlicePJSON(r, f[9])
					} else if string(key) == "recordingInfo" && c[10] {
						o.RecordingInfo = &RecordingInfo{}
						err = o.RecordingInfo.DecodeObjectPJSON(r, f[10])
					} else if string(key) == "replacementLink" && c[11] {
						o.ReplacementLink, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *Participant) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []Participant, err error) {
	var e Participant
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]Participant, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *Participant) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []Participant, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []Participant{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *ParticipantInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [10]bool{}
	f := [10][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "clientVersion" {
				c[1] = true
			} else if k == "countryCode" {
				c[2] = true
			} else if k == "endpointId" {
				c[3] = true
			} else if k == "endpointType" {
				c[4] = true
			} else if k == "identity" {
				c[5], f[5] = true, filter[i].Filter
			} else if k == "languageId" {
				c[6] = true
			} else if k == "participantId" {
				c[7] = true
			} else if k == "region" {
				c[8] = true
			} else if k == "replacementLink" {
				c[9] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "clientVersion" && c[1] {
						o.ClientVersion, err = r.String()
					} else if string(key) == "countryCode" && c[2] {
						o.CountryCode, err = r.String()
					} else if string(key) == "endpointId" && c[3] {
						o.EndpointId, err = r.String()
					} else if string(key) == "endpointType" && c[4] {
						o.EndpointType, err = r.String()
					} else if string(key) == "identity" && c[5] {
						o.Identity = &IdentitySet{}
						err = o.Identity.DecodeObjectPJSON(r, f[5])
					} else if string(key) == "languageId" && c[6] {
						o.LanguageId, err = r.String()
					} else if string(key) == "participantId" && c[7] {
						o.ParticipantId, err = r.String()
					} else if string(key) == "region" && c[8] {
						o.Region, err = r.String()
					} else if string(key) == "replacementLink" && c[9] {
						o.ReplacementLink, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *ParticipantInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []ParticipantInfo, err error) {
	var e ParticipantInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]ParticipantInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *ParticipantInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []ParticipantInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []ParticipantInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *PublishedState) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [4]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "typeRank" {
				c[1] = true
			} else if k == "type" {
				c[2] = true
			} else if k == "stateId" {
				c[3] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "typeRank" && c[1] {
						o.TypeRank, err = r.Int()
					} else if string(key) == "type" && c[2] {
						o.Type, err = r.String()
					} else if string(key) == "stateId" && c[3] {
						o.StateId, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *PublishedState) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []PublishedState, err error) {
	var e PublishedState
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]PublishedState, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *PublishedState) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []PublishedState, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []PublishedState{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *RecordingInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [3]bool{}
	f := [3][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "initiator" {
				c[1], f[1] = true, filter[i].Filter
			} else if k == "recordingStatus" {
				c[2] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "initiator" && c[1] {
						o.Initiator = &IdentitySet{}
						err = o.Initiator.DecodeObjectPJSON(r, f[1])
					} else if string(key) == "recordingStatus" && c[2] {
						o.RecordingStatus, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *RecordingInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []RecordingInfo, err error) {
	var e RecordingInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]RecordingInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *RecordingInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []RecordingInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []RecordingInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *ResultInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [4]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "code" {
				c[1] = true
			} else if k == "message" {
				c[2] = true
			} else if k == "subcode" {
				c[3] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "code" && c[1] {
						o.Code, err = r.Int32()
					} else if string(key) == "message" && c[2] {
						o.Message, err = r.String()
					} else if string(key) == "subcode" && c[3] {
						o.Subcode, err = r.Int32()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *ResultInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []ResultInfo, err error) {
	var e ResultInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]ResultInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *ResultInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []ResultInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []ResultInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *ServiceHostedMediaConfig) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [2]bool{}
	f := [2][]parse.Filter{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "preFetchMedia" {
				c[1], f[1] = true, filter[i].Filter
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "preFetchMedia" && c[1] {
						o.PreFetchMedia, err = (*MediaInfo)(nil).DecodeSlicePJSON(r, f[1])
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *ServiceHostedMediaConfig) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []ServiceHostedMediaConfig, err error) {
	var e ServiceHostedMediaConfig
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]ServiceHostedMediaConfig, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *ServiceHostedMediaConfig) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []ServiceHostedMediaConfig, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []ServiceHostedMediaConfig{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *TokenMeetingInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [2]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "token" {
				c[1] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "token" && c[1] {
						o.Token, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *TokenMeetingInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []TokenMeetingInfo, err error) {
	var e TokenMeetingInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]TokenMeetingInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *TokenMeetingInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []TokenMeetingInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []TokenMeetingInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *ToneInfo) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	c := [3]bool{}
	if filter == nil {
		for i := range c {
			c[i] = true
		}
	} else {
		for i := range filter {
			k := filter[i].Field
			if k == "@odata.type" {
				c[0] = true
			} else if k == "sequenceId" {
				c[1] = true
			} else if k == "tone" {
				c[2] = true
			}
		}
	}
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					if string(key) == "@odata.type" && c[0] {
						o.ODataType, err = r.String()
					} else if string(key) == "sequenceId" && c[1] {
						o.SequenceId, err = r.Int64()
					} else if string(key) == "tone" && c[2] {
						o.Tone, err = r.String()
					} else {
						err = r.Skip()
					}
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *ToneInfo) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []ToneInfo, err error) {
	var e ToneInfo
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]ToneInfo, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *ToneInfo) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []ToneInfo, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []ToneInfo{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *ValidationError) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	var key []byte
	_ = key
	err = r.OpenObject()
	if r.Token() != reader.TerminatorToken {
		for err == nil {
			if key, err = r.Key(); err == nil {
				if r.IsNull() {
					r.SkipNull()
				} else {
					err = r.Skip()
				}
				if err == nil && !r.Next() {
					break
				}
			}
		}
	}
	if err == nil {
		err = r.CloseObject()
	}
	return
}

func (o *ValidationError) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []ValidationError, err error) {
	var e ValidationError
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]ValidationError, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *ValidationError) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []ValidationError, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []ValidationError{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}

func (o *ResourceType) DecodeObjectPJSON(r *reader.Reader, filter []parse.Filter) (err error) {
	*(*int)(o), err = r.Int()
	return
}

func (o *ResourceType) sequencePJSON(r *reader.Reader, filter []parse.Filter, idx int) (res []ResourceType, err error) {
	var e ResourceType
	if err = e.DecodeObjectPJSON(r, filter); err == nil {
		if !r.Next() {
			res = make([]ResourceType, idx+1)
			res[idx] = e
			return
		} else if res, err = o.sequencePJSON(r, filter, idx+1); err == nil {
			res[idx] = e
		}
	}
	return
}

func (o *ResourceType) DecodeSlicePJSON(r *reader.Reader, filter []parse.Filter) (res []ResourceType, err error) {
	if err = r.OpenArray(); err == nil {
		if r.Token() == reader.TerminatorToken {
			res = []ResourceType{}
			err = r.CloseArray()
		} else if res, err = o.sequencePJSON(r, filter, 0); err == nil {
			err = r.CloseArray()
		}
	}
	return
}
